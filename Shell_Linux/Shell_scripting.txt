###########################################################################################################################################################################################
WINDOWS COMMANDS (cmd prompt): https://www.thomas-krenn.com/en/wiki/Cmd_commands_under_Windows
###########################################################################################################################################################################################

BASIC COMMANDS :
-------------------
help < command > -->  Get help on a command
cls	             -->  clear screen
cmd	             -->  start command prompt
date	           -->  show/set date
dir              -->  show	list directory content
echo	           --> 	showtext output
exit             --> 	show	exits the command prompt or a batch file
find             --> 	show	find files
hostname         --> 	show	display host name
shutdown         --> 	show	shutdown the computer
sort             --> 	show	sort the screen output
start	           --> 	showstart an own window to execute a program or command
taskkill         --> 	show	terminate a process or a application
tasklist         --> 	show	display applications and related tasks
time	           --> 	showdisplay/edit the system time
timeout	         --> 	showwait any time
fc	             --> 	showcopare files and display the differences
mkdir	           --> 	showcreate a new directory
move             --> 	show	move/rename files
rename           --> 	show	rename files
replace	         --> 	showreplace files
rmdir / rd       --> 	show	delete directory
tree             --> 	show	display folder structure graphically
type             --> 	show	display content of text files

NETWORK COMMANDS :
-----------------------
ftp              --> 	show	transfer files to a FTP server
ftype	           --> 	showdisplay file type and mapping
getmac           --> 	show	display MAC address
ipconfig         --> 	show	display IP network settings
netsh            --> 	show	configure/control/display network components
netstat          --> 	show	display TCP/IP connections and status
nslookup         --> 	show	query the DNS
pathping         --> 	show	test the connection to a specific IP address
ping             --> 	show	pings the network
route	           --> 	showdisplay network routing table, add static routes
systeminfo       --> 	show	displays computer-specific properties and configurations
telnet           --> 	show	establish Telnet connection
tftp             --> 	show	transfer files to a TFTP server
tracert          --> 	show	trace routes similar to patchping

FILE COMMANDS :
-------------------
attrib           --> 	show	display file attributes
comp             --> 	show	compare file contents
compact	         --> 	showdisplay/change file compression
copy / xcopy     --> 	show	copy files
diskcomp         --> 	show	compare content of two floppy disks
diskcopy         --> 	show	copy floppy disc to another one
erase / del      --> 	show	delete one or more files
expand           --> 	show	extract files

WINDOWS ENVIRONMENTAL VARIABLES : // https://ss64.com/nt/syntax-variables.html
-----------------------------------
Environment variables are mainly used within batch files, they can be created, modified and deleted for a session using the SET command. To make permanent changes, use SETX
Variables can be displayed using either SET or ECHO.
Variables have a percent sign on both sides: %ThisIsAVariable%
The variable name can include spaces, punctuation and mixed case: %_Another Ex.ample%
(This is unlike Parameter variables which only have one % sign and are always one character long: %A )

A variable name may include any of the following characters:
A-Z, a-z, 0-9, # $ ' ( ) * + , - . ? @ [ ] _ ` { } ~
The first character of the name must not be numeric.

--> echo %PATH% and echo %path% are same, they both print the PATH variable value.
    echo path will print "path" only. Use % before and after a variable to print its value.

###########################################################################################################################################################################################
 USE LINUX ON WINDOWS :
###########################################################################################################################################################################################
Install WSL using steps provided in https://www.computerhope.com/issues/ch001879.htm
WSL stands for WINDOWS SUBSYSTEM FOR LINUX !! Its a way for you to use linux in Windows.
Then do win+R --> bash or open UBUNTU app directly.
The name mnt stands for "mount," which is where your Windows drives are mounted within WSL.
For instance, your D: drive would be /mnt/d/, Your C: drive is located at: /mnt/c/ etc.

SUDO COMMAND : // Stands for " SUPER USER DO
-------------------------
The sudo command allows you to run programs with the security privileges of another user (by default, as the superuser/root).
sudo was developed as a way to temporarily grant a user administrative rights. To make it work, use sudo before a restricted command. The system will prompt for your password. Once provided, the system runs the command.
It prompts you for your personal password and confirms your request to execute a command by checking a file, called sudoers, which the system administrator configures.
Using the sudoers file, system administrators can give certain users or groups access to some or all commands without those users having to know the root password.
It also logs all commands and arguments so there is a record of who used it for what, and when.
This command is limited to users with administrator privileges. Users can be added or removed from /etc/sudoers.

apt vs apt-get vs yum : // apt is the newer version of apt-get
---------------------------
YUM : Yellowdog Updater, Modified
APT : Advanced Package Tool

Apt is a command line interface  for the package management system.
apt update        :  is used to download package information from all configured sources.
apt upgrade       :  is used to install available upgrades of all packages currently installed in the system. New Packages will be installed if required to satisfy the dependencies but old packages will never be removed.
apt full-upgrade  :  does an upgrade functionality and also remove currently installed packages if this is needed to upgrade the  system as a whole.
apt install       :  does action on one or more packages specified.

Installing is basically the same, you do 'yum install package' or 'apt-get install package' you get the same result.
Yum automatically refreshes the list of packages, whilst with apt-get you must execute a command 'apt-get update' to get the fresh packages.
The old apt-get upgrade command updates all the packages which currently exist in your system.
It does not install or remove the existing package on your system. However, the new apt upgrade command installs packages that were added as dependencies of upgradable packages.

        // The apt update and apt upgrade commands can be used to update package repos and upgrade packages, respectively
        apt command	               The command it replaces	           Function of the command
        ------------------------------------------------------------------------------------------
        apt update	               apt-get update	                     Refreshes repository index
        apt upgrade	               apt-get upgrade	                   Upgrades all upgradable packages
        apt install	               apt-get install	                   Installs a package


SU COMMAND :
------------------
The Linux command ‘su’ is used to switch from one account to another. User will be prompted for the password of the user switching to.
    $ su linuxandubuntu
    password:
    linuxandubuntu@sandy:~$

By default, the root user account password is locked in Ubuntu Linux for security reasons.
As a result, you can not login using root user or use a command such as ‘su -‘ to become a SuperUser.
The procedure to change the root user password on Ubuntu Linux:
  1. Type the following command to become root user and issue passwd:
     sudo -i
     passwd
  2. OR set a password for root user in a single go: // PREFERRABLE, this creates a password for root user.
     sudo passwd root
  3. Test it your root password by typing the following command:
     su -

When you are logged in as root, the command prompt should end with # instead of $.
    dileep@Dileep-MSD7:~$ sudo -s
    Enter Password :
    root@Dileep-MSD7:/home/dileep#

NOTE : By default when you change to root, you can not list the files and directories because now you are in directory "/root".
       Do a "cd .." and navigate to "/user/dileep" to see the regular files and directories.

#####################################################################################################################################################################################
BASIC LINUX COMMANDS & USAGE :
###########################################################################################################################################################################################
Everything in Linux is considered a file to maintain consistency. That includes hardware devices, printers, directories, and processes.
Regular files such as music, text, videos, and other multimedia files also have additional data associated with them called metadata.
We can run two or more commands directly at one go using ";" as in "date;who;ls" .
Use option -v for most of the commands to get a verbose display of what's happening in the background.

A file system is divided into two parts – data blocks and inodes. The number of blocks is fixed once created, and can’t be changed.
The name, path, location, links and other file attributes are not located in the directory. Directories are simply tables that contain the names of the files with the matching inode number.
You can create a hard link resulting in more than one name for the same file. When you create a hard link, it also creates a new name in the table with the inode but doesn’t move the file.
If you were to move a large file, it would take a long time. It’s more efficient to create the name entry in a new directory and delete the old entry. You can also rename files in the same way.

The top part of the hierarchy is the file system itself. Within the file system are the file names. The file names link to the inodes. The inodes link to the physical data.
FILE SYSTEM ----->  FILE NAMES -----> INODES  -----> PHYSICAL data

Inodes point to blocks that make up a file. The inode contains all the administrative data needed to read a file. Every file’s metadata is stored in inodes in a table structure.
Every inode in the Linux structure has a unique number identified with it. It is also called the index number and has the following attributes:
    -->     Size
    -->     Owner
    -->     Date/time
    -->     Permissions and access control
    -->     Location on the disk
    -->     File types
    -->     Number of links
    -->     Additional metadata about the file
    -->     To check the list of inode numbers, use the following command: ls -i

NOTE : Vi stands for Visual. It is a text editor that is an early attempt to a visual text editor.
       Vim stands for Vi IMproved. It is an implementation of the Vi standard with many additions.

1. help :  a. command --help  -> help is a bash built-in, providing help for bash commands only.
           b. man command     -> A little less descriptive than info but straight to point .
           c. info command    -> describe all about the command in detail. Lots and lots of pages of information for a single command.
           d. man command | less -> Preferable to read the description from beginning.

2. more -> When the text passed to it is too large to fit on one screen, it pages it. You can scroll down but not up.
           press enter or spacebar to navigate and q to exit.
           more /path/to/logile.txt
           more -10 /path/.. to set number of lines a page should contain
           more +10 /path/... to start from a specific line (here 10)
           cat /path/to/logfilr.txt | more
           ls --help | more

3. less -> You can scroll both up and down unlike more command.
           less /path/... -> now enter /<string> to highlight the string needed.
           less -N -> display line numbers (not available in more )
           The main difference between more and less is that less command is faster because it does not load the entire file at once and allows navigation though file using page up/down keys

4. cat  -> textfile.txt
           cat > textfile.txt       -> opens a file to write content. press ctrl+D to save and exit
                                    -> if you do it to an already existing file , previous contents will be deleted .
           cat >> textfile.txt      -> Opens a file to append text to it if some text is already existing in it.
           cat textfile.txt         -> opens a file
           echo <text> > textfile   -> remove old contents in textfile and write <text> to it .
           echo <text> >> textfile  -> append <text> to the textfile .

           The touch command is a standard command used in UNIX/Linux operating system which is used to create, change and modify timestamps of a file.
           Basically, there are two different commands to create a file in the Linux system which is as follows:
           cat command: It is used to create the file with content.
           touch command: It is used to create a file without any content. The file created using touch command is empty. This command can be used when the user doesn’t have data to store at the time of file creation.

5. echo  ->  echo <string>            -> display string on screen
             echo $var                -> display value of variable if any
             echo <text> > textfile   -> remove old contents in textfile and write <text> to it .
             echo <text> >> textfile  -> append <text> to the textfile .
             echo *                   -> is similar to ls command
             echo -n $i               -> -n to not print new line after each iteration (useful for pyramids printing)
             echo -e " $a \n"         -> -e to interpret backslash escapes . else \n does not work

INODE :  https://helpdeskgeek.com/linux-tips/what-are-inodes-in-linux-and-how-are-they-used/
An inode is a data structure that stores various information about a file in Linux, such as the access mode (read, write, execute permissions), ownership, file type, file size, group, number of links, etc.
Each inode is identified by an integer number. An inode is assigned to a file when it is created .

6. ls ->    List files with colour schemes (blue to folders , black to files etc;)
            ls -R -> Recursive list , to list files even inside a directory .
            ls -a || la  -> list files starting with a "."
            ls -l -> use vertical listing
            ls -i -> show the inodes
            ls -s -> print size allocated
            ls -S -> sort by size and print
            ls by default sorts by name , do "ls --sort=word -opt"
            ls -l | sort and ls -l | sort -r to sort in reverse
            ls -r -> reverse while sorting
            ls -t -> Sort by time, newest first

            ls -al -> detailed list of files and permissions , storage etc;
            drwxr-xr-x                      7               esrkdlp           rnd             4096         Jun 11  2019       workspace
            [filetype-permissions] - [# od hardlinks] - [Owner-Creator] - [Owber-group] - [Size in bytes] - [Date-Time] - [Name of file/dir]
            " - " -> file
            " d " -> directory
            " c " -> character files (Device files that are not files but have file like access to hardware.)


7. cd -> Change to a directory

8. pwd -> Print the present working directory

9. mkdir -> Make a directory
            mkdir abc            -> create a dir in current directory
            mkdir /test/abc      -> create a directory abc in /test directory , error if test does not exist
            mkdir dir1 dir2 dir3 -> create multiple directories at a time
            rmdir abc            -> removes a directory

            mkdir -p a/b/c       -> create a directory and parent directories if they do not exist.
            rmdir -p a/b/c       -> Remove a directory and parent directories.
            rm -rf a/b           -> Recursive delete directory. By default rm alone will only delete a file.

10. cp -> cp stands for copy. This command is used to copy files or group of files or directory. It creates an exact image of a file on a disk with different file name.
          copies each source file to the destination directory with the same name, created if not existed but if already existed then it will be overwritten, so be careful !!.
          cp command can crate a copy in destination only if the destination directory exists else it throws error.

          cp Src_file Dest_file            --> Copies to a destination path only if the path exists.

          cp Src_file1 Src_file2 Src_file3 Dest_directory
              (For this case last argument must be a directory name. For the above command to work, Dest_directory must exist because cp command won’t create it.)

          cp -R Src_directory Dest_directory
              (cp behavior depend upon whether Dest_directory is exist or not.
              If the Dest_directory doesn’t exist, cp creates it and copies content of Src_directory recursively as it is.
              But if Dest_directory exists then copy of Src_directory becomes sub-directory under Dest_directory)

          cp -i -> interactive (asks confirmation)
          cp -f -> forcibly copy
          cp -b -> create a backup of destination  before copying
          cp -n -> To not overwrite an existing file

          IF [-i -n -f] ALL THREE ARGUMENTS ARE PRESENT , THE FINAL OPTIONS TAKES PRESIDENCE.

11. mv -> mv stands for move. mv is used to move one or more files or directories from one place to another in file system like UNIX. It has two distinct functions:
          - It rename a file or folder/directory .
          - It moves group of files to different directory.
          If the destination file doesn’t exist, it will be created.
          If the destination file exist, then it will be overwrite and the source file will be deleted. By default, mv doesn’t prompt for overwriting So be careful
          SIMILAR OPTIONS TO cp COMMAND.

12. ln ->
        HARD/SOFT links : https://ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/
        A symbolic or soft link is an actual link to the original file, whereas a hard link is a mirror copy of the original file.
        If you delete the original file, the soft link has no value, because it points to a non-existent file.
        But in the case of hard link, it is entirely opposite. Even if you delete the original file, the hard link will still has the data of the original file.
        Because hard link acts as a mirror copy of the original file. A link in UNIX is a pointer to a file. Creating links is a kind of shortcuts to access a file.
        Links allow more than one file name to refer to the same file, elsewhere.

        There are two types of links  :
         1. Soft Link or Symbolic links -> Symbolic links are not updated (they merely contain a string which is the pathname of its target)
                  $ ln  -s [original filename] [link name]
                  // soft link don't share the same inode number and permissions of original file.
                  can cross the file system,
                  allows you to link between directories, has different inode number and file permissions than original file,
                  permissions will not be updated upon a change in permission of actual file,

                  It has only the path of the original file, not the contents.
                  so if we want to view the contents of the linked file, it will just transparently show the contents from the original file.
                  It does not hold the contents with it . It just points unlike hardlinks where the contents are duplicated

                  If the original file is moved to another directory, the link expires and contents are not shown.
                  Move back again to the original place and the link regenerates to original content.

                          esekilxv8818 [15:15] [/home/esrkdlp] -> mkdir links
                          esekilxv8818 [15:15] [/home/esrkdlp] -> cd links
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> echo "sample text" > abc.txt
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls
                          abc.txt
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> ln -s abc.txt efg.txt
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls
                          abc.txt  efg.txt
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> cat abc.txt
                          sample text
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> cat efg.txt
                          sample text
                          esekilxv8818 [15:16] [/home/esrkdlp/links] -> ls -lia
                          total 16
                          2990710331 drwxr-xr-x  2 esrkdlp rnd  4096 Nov 19 15:16 .
                          3028884948 drwxr-xr-x 74 esrkdlp rnd 12288 Nov 19 15:15 ..
                          2990710332 -rw-r--r--  1 esrkdlp rnd    12 Nov 19 15:16 abc.txt
                          2990710333 lrwxrwxrwx  1 esrkdlp rnd     7 Nov 19 15:16 efg.txt -> abc.txt
                          esekilxv8818 [15:17] [/home/esrkdlp/links] -> rm abc
                          abc.txt  efg.txt
                          esekilxv8818 [15:17] [/home/esrkdlp/links] -> rm abc.txt
                          rm: remove regular file `abc.txt'? y
                          esekilxv8818 [15:17] [/home/esrkdlp/links] -> ls
                          efg.txt
                          esekilxv8818 [15:17] [/home/esrkdlp/links] -> cat efg.txt
                          cat: efg.txt: No such file or directory


           2. Hard Links -> hard links always refer to the source, even if moved or removed
                    $ ln [original filename] [link name]
                    can't cross the file system boundaries (i.e. A hardlink can only work on the same filesystem),
                    can't link directories, has the same inode number and permissions of original file,
                    permissions will be updated if we change the permissions of source file,
                    So a change in the original file will also make the similar changes to the linked file.
                    If the original file is moved to another directory, the link does not expires and contents are shown.

NOTE :
If you copy a file using the "cp" command, it will just duplicate the content. So if you modify the content of a one file (either original or hard link), it has no effect on the other one.
However if you create a hard link using "ln" command to a file and change the content of either of the files, the change will be seen on both. This is quite different to copying using a "cp" command.

13. sort -> SORT command is used to sort a file, arranging the records in a particular order.
            Lines starting with a number will appear before lines starting with a letter.
            Lines starting with a letter that appears earlier in the alphabet will appear before lines starting with a letter that appears later in the alphabet.
            Lines starting with a lowercase letter will appear before lines starting with the same letter in uppercase.
            sort abc.txt
            sort -o abc.txt def.txt  -> send the output to destination def.txt
            sort -r abc.txt          -> sort in reverse order
            sort -c abc.txt          -> check if file is sorted
            sort -u abc.txt          -> sort and remoce duplicates
            sort -n abc.txt          -> numerical sort
            sort -k xn abc.txt       -> sort using the column number x (useful for tables)


14. rm ->  rm stands for remove here. rm command is used to remove objects such as files, directories, symbolic links and so on from the file system like UNIX.
           To be more precise, rm removes references to objects from the filesystem, where those objects might have had multiple references (for example, a file with two different names). By default, it does not remove directories.
           Simple rm command can only delete files but not directories.
           To delete directories and subdirectories, we use "rm -rf" --> r for recursive and f for force delete without prompts.
           So commands rmdir and rm -rf , basically do the same.
            rm file1 file2
            rm -i file -> interactive remove
            rm -f file -> forece remove
            rm -r file -> recursive remove
            rm -rf dir -> recursive remove directory

15. chmod ->  chmod {u|g|o|a} {+|-|=} {r|w|x} {filename}
                  drwxr-xr-x  -> [type][(owner)(group)(others)]

                  TYPE  ###    - -> Regular File           ; d -> Directory         ;  c -> Character file
                  WHO   ###    u -> User who owns the file ; g -> Group file owner  ;  o -> User classified as other ;  a -> All of above (u+g+o)
                  WHAT  ###    + -> Set permission         ; - -> Remove permission ;  = -> set and remove others
                  WHICH ###    r -> Read permission        ; w -> Write permission  ;  x -> Execute permission

                  0: (000) No permission.
                  1: (001) Execute permission.
                  2: (010) Write permission.
                  3: (011) Write and execute permissions.
                  4: (100) Read permission.
                  5: (101) Read and execute permissions.
                  6: (110) Read and write permissions.
                  7: (111) Read, write, and execute permissions.

              1. chmod u=rw,og=r new_file.txt (wipe out previous and set)
              2. chmod a+x new_script.sh  (add an extra. a+x is similar to +x )
              3. chmod -R o-r *.page (for subdirectories and files ending in .page)
              4. chmod 664 *.page

16. sudo ->  You only need root/sudo privileges, only if the command involves files or directories not owned by the user or group running the commands
             By default, the password you entered for sudo is retained for 15 minutes per terminal. This eliminates the need of entering the password time and again
             Sudo program allows regular users to run programs with the security privileges of the superuser or root.
             Sudo maintains a log of each command run. System administrators can trackback the person responsible for undesirable changes in the system.

17. history ->  To fetch the history of typed in commands.

18. clear   ->  Clears the screen and gives a clean window.

19. apt-get ->  ADVANCED PACKAGING TOOL
                In Linux/UNIX, installation files are distributed as packages. But the package contains only the program itself.
                Any dependent components will have to be installed separately which are usually available as packages themselves.
                Its main task is to retrieve the information and packages from the authenticated sources for installation, upgrade and removal of packages along with their dependencies.
                sudo apt-get update -> update all packages installed in our system.

                update  : This command is used to synchronize the package index files from their sources again. You need to perform an update before you upgrade or dist-upgrade.
                          apt-get update
                upgrade : This command is used to install the latest versions of the packages currently installed on the user’s system from the sources enumerated in /etc/apt/sources.list. The installed packages which have new packages available are retrieved and installed
                          apt-get upgrade
                install : This command is used to install or upgrade packages. It is followed by one or more package names the user wishes to install. All the dependencies of the desired packages will also be retrieved and installed.
                          apt-get install [...PACKAGES]
                remove  : This is similar to install, with the difference being that it removes the packages instead of installing. It does not remove any configuration files created by the package.
                          apt-get remove [...PACKAGES]

20. wc : It is used to find out number of lines, number of words count, byte and characters count in the files specified in the file arguments.
                $ wc state.txt capital.txt
                5   7  63 state.txt    // new-line-count   word-count   byte-count   file-name
                5   5  45 capital.txt
                10  12 108 total

                $wc -l --> Print new line counts (to count number of lines)
                $wc -w --> Print word count


21. who am i ## whoami ## who: To show the user information .
                who am i gives more info than whoami. Also the date and time is printed .
                who is used to show who is logged in at the moment . gives multiple names

                Other commands include -> users , who , w

22. Head :  print the top N number of data of the given input. By default, it prints the first 10 lines of the specified files. If more than one file name is provided then data from each file is preceded by its file name.
            head -n 5 state.txt -> print n lines
            head -c 6 state.txt -> print c bytes
            head -n 20 state.txt | tail -10  -> Print line between M and N lines
            head -n -15  -> cut the last 15 lines

// Head and tail by default print first and last 10 rows respectively.
// Head -n 5 a.txt == head -5 a.txt
// Tail -n 5 b.txt == Tail -5 b.txt

23. Tail : print the last N number of data of the given input. By default it prints the last 10 lines of the specified files.
           If more than one file name is provided then data from each file is precedes by its file name.
           similar options as head command.

24. grep : The grep filter searches a file for a particular pattern of characters, and displays all lines that contain that pattern
           grep -i regex file -> case insensitive searches
           grep -r            -> Recursive search
           grep -c regex file -> count of matches
           grep -w regex file -> search the whole word instead of a regular expression
           grep -n regex file -> show line numbers
           grep -v regex file -> lines not matching with regex

25. which : prints the executable path .

26. uniq : The uniq command in Linux is a command line utility that reports or filters out the repeated lines in a file.
           In simple words, uniq is the tool that helps to detect the adjacent duplicate lines and also deletes the duplicate lines.
           uniq filters out the adjacent matching lines from the input file(that is required as an argument) and writes the filtered data to the output file .

             Note: uniq isn’t able to detect the duplicate lines unless they are adjacent.
             The content in the file must be therefore sorted before using uniq or you can simply use sort -u instead f uniq.

29. SOURCE : source is a shell built-in command which is used to read and execute the content of a file(generally set of commands), passed as an argument in the current shell script.
             The command after taking the content of the specified files passes it to the TCL interpreter as a text script which then gets executed.
             If any arguments are supplied, they become the positional parameters when filename is executed.
             Otherwise, the positional parameters remain unchanged.
             The entries in $PATH are used to find the directory containing FILENAME, however if the file is not present in $PATH it will search the file in the current directory

30. find : Find command is used to search and locate the list of files and directories based on conditions you specify for files that match the arguments.
           Find can be used in a variety of conditions like you can find files by permissions, users, groups, file type, date, size, and other possible criteria.
           find <path> <options> <file/dir>
           find /home -iname tecmint.txt (i for ignorecase)
           find / -type d -name Tecmint (search for directory)
           find . -type f -name tecmint.php (search for file)


###########################################################################################################################################################################################
PROCESS HANDLING  :
###########################################################################################################################################################################################
PROCESS : An instance of a program is called a Process. In simple terms, any command that you give to your Linux machine starts a new process.
          Foreground Processes: They run on the screen and need input from the user. For example Office Programs
          Background Processes: They run in the background and usually do not need user input. For example Antivirus.

BG - FG - JOBS :
==================
If you start a foreground program/process from the terminal, then you cannot work on the terminal, till the program is up and running.
Particular, data-intensive tasks take lots of processing power and may even take hours to complete. You do not want your terminal to be held up for such a long time.
To avoid such a situation, you can run the program and send it to the background so that terminal remains available to you. Let's learn how to do this -

      bg - put suspended process into background
      fg - bring process into foreground
      jobs - list processes

--> Execute the "jobs" command to get the details of the  processes running and killed (killed using ctrl+z)
    $jobs
    [1]+ Stopped  gedit a.txt
    [2]- Stopped  ping google.com
    [3]  Stopped  vim c
    [4]  Running  nedit c.txt

--> Now Execute the command "fg %1" or "fg %2" to bring the respective job to the foreground.
--> Now if a process is running in the foreground, and if we want to send it to background, first we can kill it using "ctrl+Z".
    Now check the "jobs" command to list all the processes in the current session.
    Now use the "bg %4" command to send the stopped process to the background so that we can continue using the terminal.


Top  :  This utility tells the user about all the running processes on the Linux machine.
        Press "q" to move back to the terminal
        top allows you display of process statistics continuously until stopped vs. ps which gives you a single snapshot.
        top enables you to see your processes ordered by the amount of processor power they use.
        ps enables you to see all your processes, or just the processes used by certain users, for example root or yourself.

        FIELD       DESCRIPTION
        -------------------------
        PID	        The process ID of each task
        User	      The username of task owner
        PR        	Priority Can be 20(highest) or -20(lowest)
        NI        	The nice value of a task
        VIRT      	Virtual memory used (kb)
        RES	        Physical memory used (kb)
        SHR	        Shared memory used (kb)
        S	          Status -- 'D' = uninterruptible sleep -- 'R' = running -- 'T' = traced or stopped -- 'S' = sleeping --  'Z' = zombie
        %CPU      	% of CPU time
        %MEM      	Physical memory used
        TIME+     	Total CPU time
        Command   	Command executed

ps   :  This command stands for 'Process Status'. It is similar to the "Task Manager" that pop-ups in a Windows Machine when we use Cntrl+Alt+Del.
        This command is similar to 'top' command but the information displayed is different.
        --> ps aux   //  You can do "ps a" or "ps au" or "ps aux | grep chrome"
            The aux options are as follows:
              a = show processes for all users
              u = display the process’s user/owner
              x = also show processes not attached to a terminal

kill : This command terminates running processes on a Linux machine.
       To use these utilities you need to know the PID (process id) of the process you want to kill.
       There are also different signals that can be sent to both kill commands. What signal you send will be determined by what results you want from the kill command.
       For instance, you can send the HUP (hang up) signal to the kill command, which will effectively restart the process.
       You can get a list of all the signals that can be sent to the kill command by issuing kill -l.
       --> kill -l // will give all the signals , nearly 65 signals.
       --> Now use the " kill - <signal> <pid> " to kill a process .
           ex : kill -9 3827

           Signal Name   Single Value  Effect
           SIGHUP        1             Hangup
           SIGINT        2             Interrupt from keyboard
           SIGKILL       9             Kill signal

Nice  : Linux can run a lot of processes at a time, which can slow down the speed of some high priority processes and result in poor performance.
        To avoid this, you can tell your machine to prioritize processes as per your requirements.
        This priority is called Niceness in Linux, and it has a value between -20 to 19. The lower the Niceness index, the higher would be a priority given to that task.
        The default value of all the processes is 0. To start a process with a niceness value other than the default value use the following syntax
           -->  nice -n 'Nice value' process name

        If there is some process already running on the system, then you can 'Renice' its value using syntax.
           --> renice 'nice value' -p 'PID'
Df    : Reports the free disk space(Hard Disk) on all the file systems.
        Use "df -h" for a more readable format.

Free  : This command shows the free and used memory (RAM) on the Linux system.
        You can use the arguments "free -m"  to display output in  & "free -g"  to display output in GB.


**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
:::: SHELL SCRIPTING ::::
**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************

KERNAL :
----------
Kernel is hart of an O/S say linux-OS .. It manages resource of Linux O/S. Resources means facilities available in Linux.
It is reasonable for communication between Hardware and Software.
A system may have many shells but only one kernal .
For eg. Facility to store data, print data on printer, memory, file management etc . Kernel decides who will use this resource, for how long and when.
It runs your programs (or set up to execute binary files) It's Memory resident portion of Linux. It performance following task :-
● I/O management          |
● Process management      |
● Device management       |   ---> F O D I M P
● File management         |
● Memory management       |

Operating system is a system software. Kernel is a part of operating system.
Operating system acts as an interface between user and hardware. When computer boots up Operating System is the first program that loads. It also provides protection and security.
Kernel acts as an interface between applications and hardware, which coverts user command into machine language. When Operating System boots up Kernal is the first program that loads. It’s main purpose is memory management, disk management, process management and task management.

USER -> TERMINAL -> SHELL -> KERNAL -> HARDWARE
USER -> APPLICATIONS -> OS -> HARDWARE

 --------------------------------------------------------------------- -------------------------
|                            ===============================          |                         |
|    --------              ||   --------------------------  ||        |        ---------        |  <<-->>  | USER-1 |
|  | HARDWARE |   <<-->>   ||  | [[ KERNAL ]] [[GNU-SW]]  | ||      <<-->>    | TERMINAL |      |  <<-->>  | USER-2 |
|    --------              ||  |    OPERATING SYSTEM      | ||        |        ----------       |
|                          ||   --------------------------  ||        |                         |
|                          ||     ---------    ---------    ||        |                         |
|                          ||    | SHELL-1 |  | Shell-2 |   ||        |                         |
|                          ||     ---------    ---------    ||        |                         |
|                            ===============================          |             ^           |
|--------------------------------------------------------------------- ----------   |  ---------|
|                    Applications , cd , ls , grep , compilers etc ;                V           |  <<-->>  | USER-3 |
 -----------------------------------------------------------------------------------------------   <<-->>  | USER-4 |


LINUX is a KERNAL , not an OS . Its a clone of UNIX KERNAL .
LINUX KERNAL + GNU SOFTWARE = OPERATING SYSTEM (say Ubuntu / Redhat)
Everything in LINUX is a file even a printer and a mouse .

UNIX OS  : HP-UX , IBM AIX , SUN SOLARIS , MAC OS X .(Paid services)
LINUX OS : REDHAT , DEBIAN , UBUNTU. (Free and open source but some priced versions are available )


POSIX :
-------
Portable Operating System interface is a family of standards specified by IEEE for maintaining compatibility between operating systems.


SHELL : ( a macro processor that executes commands) :
-----------------------------------------------------
In computing, a shell is a computer program which exposes an operating system's services to a human user or other program .
In general, operating system shells use either a command-line interface (CLI) or graphical user interface (GUI), depending on a computer's role and particular operation
It is named a shell because it is the outermost layer around the operating system.
A command-line interface (CLI) is an operating system shell that uses alphanumeric characters typed on a keyboard to provide instructions and data to the operating system.
Including various services to their users, including file management, process management (running and terminating applications), batch processing, and operating system monitoring and configuration.
MICROSOFT WINDOWS -> Windows Shell and Power shell
LINUX/UNIX  -> Bourne again Shell (bash) , unix shell , Bourne shell (sh) , C SHELL (csh) , KORN SHELL(ksh)

In Unix, there are two major types of shells −
Bourne shell − If you are using a Bourne-type shell, the $ character is the default prompt.
C shell − If you are using a C-type shell, the % character is the default prompt.

The Bourne Shell has the following subcategories −
    Bourne shell (sh)
    Korn shell (ksh)
    Bourne Again shell (bash)
    POSIX shell (sh)

The different C-type shells follow −
    C shell (csh)
    TENEX/TOPS C shell (tcsh)

Users communicate with the kernel through a program known as the shell.
The shell is a command line interpreter; it translates commands entered by the user and converts them into a language that is understood by the kernel.


UNINX SHELL :
-------------
A Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts.[
A Unix shell is both a command interpreter and a programming language.
As a command interpreter, the shell provides the user interface to the rich set of gnu utilities. The programming language features allow these utilities to be combined
Unix shells provide filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration.

Computer understand the language of 0's and 1's called binary language,
In early days of computing, instruction are provided using binary language, which is difficult for all of us, to read and write.
So in O/s there is special program called Shell. Shell accepts your instruction or commands in English and translate it into computers native binary language.

   --------------------        ------------       ---------------------------       -------
  | command/shell_script | -> | Linux shell | -> | Binary equalent of command | -> | KERNAL |
   --------------------        ------------       ---------------------------       -------

  $ls ; $date -> BASH -> 10001101 -> LINUX KERNAL

  OS = GNU S/W + KERNAL + SHELL [KERNAL handles everything and shell helps us interact with it .]


SHELL SCRIPTING :	(called BATCH files in MS-DOS) ;
--------------------------------------------------
A shell script is a computer program designed to be run by the Unix shell, a command-line interpreter
The biggest advantage of writing a shell script is that the commands and syntax are exactly the same as those directly entered at the command-line. The programmer does not have to switch to a totally different syntax, as they would if the script were written in a different language, or if a compiled language were used.
Disadvantages -> rm -rf */ and rm -rf * / (deletes everything including root ) and also that commands vary by  a single word -> cd cc df etc;


PROCESS : https://www.guru99.com/managing-processes-in-linux.html
----------
Process is any kind of program or task carried out by your PC.
For e.g. $ ls -lR , is command or a request to list files in a directory and all subdirectory in your current  directory. It is a process.
A process is program (command given by user) to perform some Job. In Linux when you start process, it gives a number (called PID or process-id), PID starts from 0 to 65535.
A DAEMON is a system related background process which requests services like printer daemon requesting printing instructions .

  PID : process id
  PPID : Parent PID

TTY : (command tty)
    terminal = tty = text input/output environment
    Teletypewriter originally and now also means any terminal on Linux/Unix systems. It also means any serial port on Unix/Linux systems.
    ps aux | grep tty

PTS :
    Stands for pseudo terminal slave.
    A pts is the slave part of a pty.
    A pty (pseudo terminal device) is a terminal device which is emulated by an other program (example: xterm, screen, or ssh are such programs).
    /dev/pts contains entries corresponding to devices. /dev/pts is a special directory that is created dynamically by the Linux kernel. The contents of the directory vary with time and reflect the state of the running system.

In laymen terms the primary difference between TTY and PTS is the type of connection to the computer.
TTY ports are direct connections to the computer such as a keyboard/mouse or a serial connection to the device.
PTS connections are SSH connections or telnet connections. All of these connections can connect to a shell which will allow you to issue commands to the computer.


FILES IN UNIX :
=================
In Unix, there are three basic types of files −

Ordinary Files − An ordinary file is a file on the system that contains data, text, or program instructions.
                 In this tutorial, you look at working with ordinary files.

Directories    − Directories store both special and ordinary files.
                 For users familiar with Windows or Mac OS, Unix directories are equivalent to folders.

Special Files  − Some special files provide access to hardware such as hard drives, CD-ROM drives, modems, and Ethernet adapters.
                 Other special files are similar to aliases or shortcuts and enable you to access a single file using different names.
                 These are located in /dev (device folder)

/     This is the root directory which should contain only the directories needed at the top level of the file structure
/bin  This is where the executable files are located. These files are available to all users
/dev  These are device drivers
/etc  Supervisor directory commands, configuration files, disk configuration files, valid user lists, groups, ethernet, hosts, where to send critical messages
/lib  Contains shared library files and sometimes other kernel-related files
/boot Contains files for booting the system
/home Contains the home directory for users and other accounts
/mnt  Used to mount other temporary file systems, such as cdrom and floppy for the CD-ROM drive and floppy diskette drive, respectively
/proc Contains all processes marked as a file by process number or other information that is dynamic to the system
/tmp  Holds temporary files used between system boots
/usr  Used for miscellaneous purposes, and can be used by many users. Includes administrative commands, shared files, library files, and others
/var  Typically contains variable-length files such as log and print files and any other type of file that may contain a variable amount of data
/sbin contains binary (executable) files, usually for system administration. For example, fdisk and ifconfig utlities


OUTPUT REDIRECTION :
======================
1. ">"  : To redirect output of a command to a file as in    -> "ls -lrt > file" .
          If the file doesn't exist it is created automatically .
          Old data if any is lost .
2. ">>" : Similar to ">" redirection but the data is appended rather than over riding .   -> "ls -lrt >> file"
          The data is written to end of file and old data stays as it is .
3. "<"  : To take input from a file instead of keyboard   -> "cat < file"

===========================================================
VARIABLES IN LINUX : (case - sensitive) // Execute command "bash" before proceeding.
===========================================================
NOTE : Only applicable for "bash" shell.
       If using other shells, execute command "bash" to experience the below functionalities .
       We might be in other shells and some commands can give irregular outputs

Shells can have variables of 2 types : LOCAL VARIABLES, which are only accessible from the current shell, and  ENVIRONMENTAL VARIABLES (exported), which are passed on to every executed program.
command " set " is a built-in shell command, it also sees shell-local variables (including shell functions). This type of variable defined in LOWER CASE LETTERS.
command " env " on the other hand is an independent executable (/usr/bin/env); it only sees the variables that the shell passes to it, or environment variables. This type of variable defined in CAPITAL CASE LETTERS.
Even simple commands, like ls, mkdir, rm, and others are just small programs that usually live inside a directory on your computer called /usr/bin.
There are other places on your system that commonly hold executable programs as well; some common ones include /usr/local/bin, /usr/local/sbin, and /usr/sbin.

We can print values of any type of variables using " echo $< variable > "  --> EX : " $ echo $USERNAME ".
We can unset values of any type of variable  using " unset < variable > "
NOTE : For echo command it is "$variable" but for unset command it is just "variable"

Command "set | wc -l" --> 150
command "env | wc -l" --> 80
The "env" command sees what "set" command wants it to see. So it is a subset of "set" command.
Command "set" will print all variables including "local + env" all in CAPITAL case. But "env" will only show the environment varibales.
So upon executing a "set" command use the "printenv" command to check if a variable is local or environmental.  // printenv var --  [not $var]


LOCAL VARIABLES :
========================
Variables created with set command are specific to a particular shell.
Each shell such as zsh and bash, has its own set of internal shell variables.
If you create a variable "a" and open another shell either by typing "bash" or by "win + shft + T" and check the value using " echo $a ", you can not find the value.
If you close a shell, all your created shell local variables are deleted.

      $ set              -> prints all shell-local variables
      $ set  dileep=1994 -> To create a shell local variable. No spaces before & after = .
      $ echo dileep      -> prints "dileep" , use $dileep instead .
      $ echo $dileep     -> 1994

      $a=10              -> also creates a variable, a = 10
      $a="20"            -> also creates a variable, a = 20
      $a="dhoni"         -> also creates a variable, a = dhoni
      $echo $a           -> will now print updated value which is dhoni.

   EXAMPLE SCENARIO :
   ---------------------
      $ var="hello"   # create shell variable "var"
      $ bash          # start _new_ bash session
      $ echo "$var"   # no output
      $ exit          # back to original shell session
      $ echo "$var"   # "hello" is outputted
      $ unset var     # remove variable


ENVIRONMENT VARIABLES :
========================
These are available system-wide and are inherited by all spawned child processes and shells.
Environment variables allow you to customize how the system works and the behaviour of the applications on the system.
For example, the environment variable can store information about the default text editor or browser, the path to executable files, or the system locale and keyboard layout settings
By convention, environment variables should have UPPER CASE names.
When assigning multiple values to the variable they must be separated by the colon : character.

      $ env                        -> Print all Environmental variables
      $ export A=10                -> Creates an environmental variable.
      $ env $ < env-variable >     -> Print value of a specified variable.                             --> env $PATH
      $ printenv < env-variable >  –> The command prints all or the specified environment variables.   --> printenv PATH  // For env command specify "$variable" , for printenv command specify just "variable"

  EXAMPLE SCENARIO :
  ---------------------
      $ export VAR="hello"  # create environment variable "VAR"
      $ bash
      $ echo "$VAR"         # "hello" is outputted since it's exported
      $ exit                # back to original shell session
      $ unset VAR           # remove variable

NOTE : To change a PATH variable, use the syntax : export PATH=$PATH:/place/with/the/file
       If you do it as export PATH=/place/with/the/file , older paths will be lost.
       So to add additional values to any environmental variable use the above syntax using the ":" symbol.

NOTE : To create an environment variable from a shell variable simply export the shell variable as an environment variable:
       set a=100   --> Create a local variable a using set command with value 100.
       printenv a  --> Does not print anything because a is a local variable.
       export a    --> Convert local variable to environment variable
       printenv a  --> prints value 100

NOTE : Use the following syntax to print a particular variable.
       set | grep user
       env | grep HOME


PERSISTANT ENVIRONMENT VARIABLES :
====================================
To make Environment variables persistent you need to define those variables in the bash configuration files.
In most Linux distributions when you start a new session, environment variables are read from the following files:

-->   /etc/environment - Use this file to set up system-wide environment variables. Variables in this file are set in the following format:
      FOO=bar
      VAR_TEST="Test Var"

-->   /etc/profile - Variables set in this file are loaded whenever a bash login shell is entered. When declaring environment variables in this file you need to use the export command:
      export JAVA_HOME="/path/to/java/home"
      export PATH=$PATH:$JAVA_HOME/bin

-->   Per-user shell specific configuration files. For example, if you are using Bash, you can declare the variables in the ~/.bashrc:
      export PATH="$HOME/bin:$PATH"
      To load the new environment variables into the current shell session after saving them, use the source command: source ~/.bashrc



EXECUTING A SHELL SCRIPT:
=======================================

(#!/usr/bin/env bash) -> the code for all commands is available in /bin folder .
some commands are shell-built_in like cd , others are written as programs in /bin . To check , execute "which <command>"
https://swcarpentry.github.io/shell-novice/06-script/index.html

1. write a file file.sh with the required code

2. You can execute it as "bash file.sh" or "sh file.sh" or "/bin/sh file.sh"
        sh filename.sh means to execute the file using the system’s basic default shell.
        Many years ago, that meant the Bourne shell, but in the POSIX era, the Bourne shell was eliminated and the much more powerful Korn shell, ksh, was given sh as a link (alias).
        But the Korn shell was new enough that it had not lost its copyright and required a fee, Bourne Again Shell, bash, and Z Shell, zsh, were developed as free substitutes.
        bash filename.sh is just naming bash directly. If you have some other shell installed as sh, you can do this to ensure that you’ll get bash and nothing else.

3. Alternatively , you can give the file executable permissions and execute it as "./file.sh" . (chmod +x file.sh)
       ./filename.sh means to execute the file on the shell you are using now, whatever it is.
       It will run it in whichever shell is invoked by the shebang (#!) line at the beginning of the script .
       Also helps OS by saying that file is in current directory and hence need not search for files available in  PATH variable .

4. We can even rename "file.sh" to just "file" to give it more of an elite look, and because bash honestly doesn't care what you name your files or what extensions you give it
        Then you can execute directly as "./file"

5. We can remove "./", by moving file into a directory that's part of the bash environment's executable PATH .
        Then you can execute simply by doing "file"


EXECUTE LINUX COMMANDS :
==========================
To execute a linux command, do "$(command)" as in $echo "current dir is $(pwd)"
Also you can use `date`. As in -> echo " today is `date` "  or also as echo " today is $(date) " .


$ echo 3 + 5 -> prints 3 + 5
$ expr 3+5   -> prints 3+5 , use spaces .
$ expr 3 + 5 -> 8
$ echo "Todays date is `date`"  -> Todays date is TUE NOV 24 16:17:12 IST 2020
$ echo `expr 3 + 5`    -> 8
$ echo ` 2 + 3`   -> error

COMMAND LINE ARGUMENTS : https://www.grymoire.com/Unix/Quote.html
============================
Consider a command : myfile foo bar
Here $# will be 2 (Since foo and bar only two Arguments),
Please note At a time such 9 arguments can be used from $0..$9.
You can also refer all of them by using $* (which expand to `$0,$1,$2...$9`).

$# :The number of arguments supplied to a script.
$* :All the arguments are double quoted. If a script receives two arguments, $* is equivalent to $1 $2.
$@ :All the arguments are individually double quoted. If a script receives two arguments, $@ is equivalent to $1 $2.
$? :The exit status of the last command executed. -> 0 is a success , non-zero is failure
$$ :The process number of the current shell. For shell scripts, this is the process ID under which they are executing.
$! :The process number of the last background command.

NOTE : https://unix.stackexchange.com/questions/129072/whats-the-difference-between-and
There is no difference between $* and $@ but there is difference between "$*" and "$@" . Check below
#!/bin/bash
echo "With *:"
for arg in "$*"; do echo "<$arg>"; done
echo
echo "With @:"
for arg in "$@"; do echo "<$arg>"; done

$ /tmp/test.sh 1  2 "3  4"
With *:
<1 2 3 4>

With @:
<1>
<2>
<3  4>


-> bash file.sh 1 2 3 4 5
$# = 5 ; $* = 1 2 3 4 5
-> ./file.sh 1 2 3 4 5
$# = 5 ; $* = 1 2 3 4 5

ARRAYS :
===========
Syntax to access elements of an array : ${array_name[index]}
You can access all the items in an array in one of the following ways −
${array_name[*]}
${array_name[@]}

######################################################

# Select lines from the middle of a file.
# Usage: bash middle.sh filename end_line num_lines
head -n "$2" "$1" | tail -n "$3"
(or)
wc -l "$@" | sort -n    -> if we have more than 1 file to process .


EXIT STATUS : ($?)
===================
By default in Linux if particular command is executed, it return two type of values, (Values are used to see whether command is successful or not)
if return value is zero (0), command is successful,
if return value is nonzero (>0), command is not successful
or some sort of error executing command/shell script.
This value is know as Exit Status of that command. To determine this exit Status we use $? variable of shell.

ARITHEMATIC OPERATIONS : (for Multiplication it is \* , not *)
==========================
+ (Addition)	Adds values on either side of the operator	`expr $a + $b` will give 30
- (Subtraction)	Subtracts right hand operand from left hand operand	`expr $a - $b` will give -10
* (Multiplication)	Multiplies values on either side of the operator	`expr $a \* $b` will give 200
/ (Division)	Divides left hand operand by right hand operand	`expr $b / $a` will give 2
% (Modulus)	Divides left hand operand by right hand operand and returns remainder	`expr $b % $a` will give 0
= (Assignment)	Assigns right operand in left operand	a = $b would assign value of b into a
== (Equality)	Compares two numbers, if both are same then returns true.	[ $a == $b ] would return false.
!= (Not Equality)	Compares two numbers, if both are different then returns true.	[ $a != $b ] would return true.


CONDITIONAL & BOOLEAN  OPERATORS:
=======================
All the conditional expressions should be inside square braces with spaces around them.
For example [ $a == $b ] is correct whereas, [$a==$b] is incorrect.
!	This is logical negation. This inverts a true condition into false and vice versa.	[ ! false ] is true.
-o	This is logical OR. If one of the operands is true, then the condition becomes true.	[ $a -lt 20 -o $b -gt 100 ] is true.
-a	This is logical AND. If both the operands are true, then the condition becomes true otherwise false.	[ $a -lt 20 -a $b -gt 100 ] is false.

TEST COMMAND or [EXPR] : ( if test $i -eq 0   <===> if [ $i -eq 0 ] )
=========================
[[ … ]] double brackets are an alternate form of conditional expressions in ksh/bash/zsh with a few additional features,
for example you can write [[ -L $file && -f $file ]] to test if a file is a symbolic link to a regular file
whereas single brackets require [ -L "$file" ] && [ -f "$file" ]

test command or [ expr ] is used to see if an expression is true, and if it is true it return zero(0),
otherwise returns nonzero(>0) for false. Syntax: test expression OR [ expression ]
Now will write script that determine whether given argument number is positive. Write script as
follows

if test $1 -gt 0
then
 echo "$1 number is positive"
fi

#which is similar to :

if [ $1 -gt 0 ]
then
 echo "$1 number is positive"
fi

IF-THEN-FI :
================
Unix Shell supports following forms of if…else statement −
if...fi statement
if...else...fi statement
if...elif...else...fi statement

if cat $1
then
 echo -e "\n\nFile $1, found and successfully echoed"
fi

if test $1 -gt 0
then
 echo "$1 number is positive"
fi


For Mathematical Operators : [ we should specify -le and not le in code ]

-eq ======== is equal to ======================== (5 == 6) ======== if test 5 -eq 6 ======== if expr [ 5 -eq 6 ]
-ne ======== is not equal to ==================== 5 != 6   ======== if test 5 -ne 6 ======== if expr [ 5 -ne 6 ]
-lt ======== is less than ======================= 5 < 6    ======== if test 5 -lt 6 ======== if expr [ 5 -lt 6 ]
-le ======== is less than or equal to =========== 5 <= 6   ======== if test 5 -le 6 ======== if expr [ 5 -le 6 ]
-gt ======== is greater than ==================== 5 > 6    ======== if test 5 -gt 6 ======== if expr [ 5 -gt 6 ]
-ge ======== is greater than or equal to ======== 5 >= 6   ======== if test 5 -ge 6 ======== if expr [ 5 -ge 6 ]

For string Comparisons use :

string1 = string2              string1 is equal to string2
string1 != string2             string1 is NOT equal to string2
string1                        string1 is NOT NULL or not defined
-n string1                     string1 is NOT NULL and does exist
-z string1                     string1 is NULL and does exist

Shell also test for file and directory types :

-s file                        Non empty file
-f file                        Is File exist or normal file and not a directory
-d dir                         Is Directory exist and not a file
-w file                        Is writeable file
-r file                        Is read-only file
-x file                        Is file is executable

IF-THEN-ELSE-FI:
=================
# Script to see whether argument is positive or negative
if [ $# -eq 0 ]
then
 echo "$0 : You must give/supply one integers"
 exit 1
fi
if test $1 -gt 0
then
 echo "$1 number is positive"
else
 echo "$1 number is negative"
fi


IF-THEN-ELIF-THEN-ELSE-FI:
======================
# Script to test if..elif...else
if [ $1 -gt 0 ]
then
  echo "$1 is positive"
elif [ $1 -lt 0 ]
then
    echo "$1 is negative"
elif [ $1 -eq 0 ]
then
  echo "$1 is zero"
else
  echo "Opps! $1 is not number, give number"
fi

FOR LOOPS:
=============
for { variable name } in { list }
do
 execute one for each item in the list until the list is
 not finished (And repeat all statement between do and done)
done

for i in 1 2 3 4 5
do
 echo "Welcome $i times"
done

n=$1
for i in 1 2 3 4 5 6 7 8 9 10
do
 echo "$n * $i = `expr $i \* $n`"
done

WHILE LOOPS:
==============
n=$1
i=1
while [ $i -le 10 ]
do
 echo "$n * $i = `expr $i \* $n`"
 i=`expr $i + 1`
done

CASE STATEMENT :
==================
case $variable-name in
 pattern1) command
            ...
            ..
            command;;
 pattern2) command
            ...
            ..
            command;;
 patternN) command
            ...
            ..
            command;;
 *) command
            ...
            ..
            command;;
 esac

#EXAMPLE

while :
do
 clear
 echo "-------------------------------------"
 echo " Main Menu "
 echo "-------------------------------------"
 echo "[1] Show Todays date/time"
 echo "[2] Show files in current directory"
 echo "[3] Show calendar"
 echo "[4] Start editor to write letters"
 echo "[5] Exit/Stop"
 echo "======================="
 echo -n "Enter your menu choice [1-5]: "
 read yourch
 case $yourch in
 1) echo "Today is `date` , press a key. . ." ; read ;;
 2) echo "Files in `pwd`" ; ls -l ; echo "Press a key. . ." ; read ;;
 3) cal ; echo "Press a key. . ." ; read ;;
 4) vi ;;
 5) exit 0 ;;
 *) echo "Opps!!! Please select choice 1,2,3,4, or 5";
 echo "Press a key. . ." ; read ;;
 esac
done

TAKING INPUT FROM USERS :
===========================
SYNTAX : read <variable1> <variable2> etc ;

echo "Enter the user name: "
read first_name
echo "The Current User Name is $first_name"
echo
echo "Enter other users'names: "
read name1 name2 name3
echo "$name1, $name2, $name3 are the other users."

-> If you do not want to pass a variable , you can catch it in variable REPLY
echo "Enter name : "
read
echo "Name : $REPLY"

-> To enter the input on the same PROMPT by using the -p command line option as follows:
read -p "<Text>" <variable_name>
-> To not expose the user response as in passwords , use-s option
read -sp  "<Text>" <variable_name>

-> To take array of values and access them as ${var[0]} and ${var[1]} etc ;
read -a <var>

OUTPUT REDIRECTION: ( I/O redirectors are used to send output of command to file or to read input from file.)
====================
stdin  − This is referred to as the standard input and the associated file descriptor is 0. This is also represented as STDIN.
         The Unix program will read the default input from STDIN.
stdout − This is referred to as the standard output and the associated file descriptor is 1. This is also represented as STDOUT.
         The Unix program will write the default output at STDOUT
stderr − This is referred to as the standard error and the associated file descriptor is 2. This is also represented as STDERR.
         The Unix program will write all the error messages at STDERR.

Sometimes you will need to execute a command, but you don't want the output displayed on the screen
/dev/null - Use to send unwanted output of program
This is special Linux file which is used to send any unwanted output from program/command.
Syntax: command > /dev/null
For e.g. $ ls > /dev/null , output of this command is not shown on screen its send to this special file.
The /dev directory contains other device files. The files in this directory mostly represent peripheral devices such disks liks floppy disk, sound card, line printers etc.

In Linux (And in C programming Language) your keyboard, screen etc are treated as files.

Standard_File   File_Descriptors_number           Use                 Example
  stdin                 0                   as Standard input         Keyboard
  stdout                1                   as Standard output        Screen
  stderr                2                   as Standard error         Screen

You can redirect the output from a file descriptor directly to file with following
Syntax: "file-descriptor-number>filename"

$ rm bad_file_name111
rm: cannot remove `bad_file_name111': No such file or directory ,is the output (error) of the above program. Now if we try to redirect this error-output to file, it can not be send to file
$ rm bad_file_name111 > er
Still it prints output on stderr as rm: cannot remove `bad_file_name111': No such file or directory, And if you see er file as $ cat er , This file is empty, since output is send to error device and you can not redirect it to copy this error-output to your file 'er'.
$ rm bad_file_name111 2>er
Note that no space are allowed between 2 and >, The 2>er directs the standard error output to file. 2 number is default number of stderr file.

Syntax: "from>&destination"
If we want to tell users they have not specified arguments or someother but we dont to print them in stdout rather in stderr , then :
You can display a message on to STDERR by redirecting STDOUT into STDERR
echo "Error : Number are not supplied" 1>&2
echo "Usage : $0 number1 number2" 1>&2
-> Here the 1>&2 at the end of echo statement, directs the standard output (stdout) to standard error (stderr) device.


FUNCTIONS:
===========
function_name () {
   list of commands
}

--> PASS arguments :
# Define your function here
Hello () {
   echo "Hello World $1 $2"
}
# Invoke your function
Hello Zara Ali

Upon execution, you will receive the following result −
$./test.sh
Hello World Zara Ali

TRAPS :
==========
if you press ctrl + c , while running this script, script get terminated. The ctrl + c here work as signal,
When such signal occurs its send to all process currently running in your system

GETOPS for WHILE loops:
=======================
getopts is a very convenient bash script utility, which helps you to conveniently and gracefully handle the passing of flags(short version), and arguments in a clean, standardized manner.
Instead of having the developer manually handle the flags passed to a script
